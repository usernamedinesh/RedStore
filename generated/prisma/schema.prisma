generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Models start here

model CartItem {
  id        String   @id @default(uuid())
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  //Relation 
  user   User @relation(fields: [userId], references: [id])
  userId Int

  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade) // delete automatically if product is deleted
  productId String

  variantName   String?
  variantOption String?

  variantSelection Json?
  variantKey       String?
}

model Brand {
  id         String          @id @default(uuid())
  name       String
  products   Product[]
  categories CategoryBrand[] //join table
}

model Category {
  id        String          @id @default(uuid()) @map("category_id")
  name      String
  brands    CategoryBrand[]
  products  Product[]
  createdAt DateTime        @default(now()) @map("created_at")

  @@map("categories")
}

model CategoryBrand {
  brand      Brand    @relation(fields: [brandId], references: [id])
  brandId    String
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String

  @@id([brandId, categoryId]) // Composite primary key for the join table 
}

model Product {
  id          String           @id @default(uuid()) @map("product_id")
  name        String
  description String
  category    Category         @relation(fields: [categoryId], references: [id])
  categoryId  String           @map("category_id")
  brand       Brand            @relation(fields: [brandId], references: [id])
  brandId     String           @map("brand_id")
  gender      Gender           @default(UNISEX)
  basePrice   Float?           @map("base_price")
  variants    ProductVariant[]
  ratings     Rating[]
  createdAt   DateTime         @default(now()) @map("created_at")
  CartItem    CartItem[]

  @@index([name]) // For product name searches
  @@index([brandId]) // For brand filtering
  @@index([categoryId]) // For category-based queries
  @@map("products")
}

model ProductVariant {
  id        String      @id @default(uuid()) @map("variant_id")
  product   Product     @relation(fields: [productId], references: [id])
  productId String      @map("product_id")
  size      Float
  color     String
  stock     Int         @default(0)
  price     Float // i add this now i run this => npx prisma migrate dev --name add_price_to_variant
  sku       String      @unique
  createdAt DateTime    @default(now()) @map("created_at")
  OrderItem OrderItem[]

  @@index([sku]) // Critical for inventory lookups
  @@index([productId]) // For fetching all variants of a product
  @@index([size, color]) // For size/color filters
  @@map("product_variants")
}

model Rating {
  id        String   @id @default(uuid()) @map("rating_id")
  product   Product  @relation(fields: [productId], references: [id])
  productId String   @map("product_id")
  user      User     @relation(fields: [userId], references: [id])
  userId    Int      @map("user_id")
  value     Int
  // if (value < 1 || value > 5) throw new Error("Rating must be 1-5") add this 
  review    String?
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId]) // For user-specific rating queries
  @@index([productId]) // For product-specific rating queries
  @@map("ratings")
}

model Order {
  id              String        @id @default(uuid()) @map("order_id")
  user            User          @relation(fields: [userId], references: [id])
  userId          Int           @map("user_id")
  items           OrderItem[]
  totalAmount     Float         @map("total_amount")
  status          OrderStatus   @default(PENDING)
  paymentMethod   PaymentMethod
  shippingAddress Json          @map("shipping_address")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  @@index([userId]) //users orders history
  @@index([status]) // For order status filtering or for admin order management
  @@index([createdAt]) // For sorting orders by date for time base report
  @@map("orders")
}

model OrderItem {
  id        String         @id @default(uuid()) @map("order_item_id")
  order     Order          @relation(fields: [orderId], references: [id])
  orderId   String         @map("order_id")
  variant   ProductVariant @relation(fields: [variantId], references: [id])
  variantId String         @map("variant_id")
  quantity  Int
  price     Float
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @updatedAt @map("updated_at")

  @@map("order_items")
}

enum Gender {
  MEN
  WOMEN
  UNISEX
}

enum OrderStatus {
  PENDING
  PAID
  PACKED
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentMethod {
  CREDIT_CARD
  DEBIT_CARD
  COD
  UPI
  PAYPAL
  STRIPE
}

// model Rating {
//   id     Int     @id @default(autoincrement())
//   name   String
//   email  String  @unique
//   score  Int     // or Float, if rating is like 4.5 stars
// }

enum UserRole {
  USER
  ADMIN
}

model User {
  id           Int        @id @default(autoincrement())
  name         String
  email        String?    @unique
  password     String
  phoneNo      String?    @unique
  isVerified   Boolean    @default(false) // remove this too 
  userRole     UserRole   @default(USER)
  updatedAt    DateTime   @updatedAt
  createdAt    DateTime   @default(now())
  cart         CartItem[]
  refreshToken String?
  otp          String?
  otpCreatedAt DateTime?
  // expiresAt  DateTime @default(dbgenerated("(NOW() + interval '5 minutes')"))
  Rating       Rating[]
  Order        Order[]
}

// This is temperory for storing otp and email
// after successfully otp matched remove this and store to the user 

model TempOtp {
  id        Int      @id @default(autoincrement())
  otp       String
  email     String?  @unique
  phoneNo   String?  @unique
  createdAt DateTime @default(now())
  expiresAt DateTime
}
